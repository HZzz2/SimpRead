> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [medium.com](https://medium.com/@0x0vid/malware-analysis-trickbot-part-1-droppers-320bf42cc689)

> Malware analysis of phishing emails used by the Trickbot malware and subsequent droppers and their ex......

[

![](https://miro.medium.com/v2/resize:fill:88:88/1*HjaAQ_ZKbmwHrLeSI8cdfg.jpeg)

](https://medium.com/@0x0vid?source=post_page-----320bf42cc689--------------------------------)

In this post, we will go through and analyze the TrickBot malware. This family of malware was infamous for many years for its prevalence and effectiveness, [often seen in combination with Ryuk and Conti ransomware [001]](https://www.cisa.gov/news-events/cybersecurity-advisories/aa21-076a)  
在这篇文章中，我们将深入研究并分析 TrickBot 恶意软件。多年来，这个恶意软件家族以其普遍性和有效性而臭名昭著，通常与 Ryuk 和 Conti 勒索软件结合使用。【001】

Due to the many steps this malware takes to be evasive this post will be split into three different sections, this one where we will look at the series of initial droppers. The next one is where we look at more droppers, the agent, and the persistence mechanism. And finally closing off by looking at one of their “modules” used for Active Directory domain reconnaissance.  
由于这种恶意软件采取了许多措施来避免被发现，因此本文将分为三个不同的部分，第一部分将介绍初始下载器的系列。下一部分将介绍更多的下载器、代理和持久性机制。最后，我们将通过查看其中一个用于 Active Directory 域侦察的 “模块” 来结束。

The intention behind this series of blog posts is to dive into malware analysis methodology, and hopefully give some insights into how you can look at code to figure out what is happening. And also how this process looks like in practice.  
这一系列博客文章背后的意图是深入研究恶意软件分析方法，并希望为您提供一些关于如何查看代码以弄清发生了什么的见解。同时也展示这个过程在实践中是什么样子。

Samples 样本
----------

As you will see at the bottom of this post I unfortunately was unable to find the original malware dropped by the stagers, and in the next posts will therefore use substitute samples, but the main points should be the same  
抱歉，我在本帖的底部未能找到由攻击者放置的原始恶意软件样本，因此在接下来的帖子中将使用替代样本，但主要内容应该是相同的

The sample used for this first stage of analysis is a .doc file from [Malware bazzar [002]](https://bazaar.abuse.ch/sample/8ae73acc01f72c1164324e44045cd74256c3b4be606c0932717a2b593e8c5169/).  
该分析的第一阶段使用的样本是来自 Malware bazzar [002] 的. doc 文件。

*   1bmd.doc — 23f98d6ff7329618994ac0f3e2b3a394

As Trickbot is an older malware much analysis has already been done on various samples, this is quite nice for starting out as it means that you can check your work against what has been observed by others [[003]](https://www.sentinelone.com/blog/trickbot-technical-analysis-banking-trojan-malware/) [[004]](https://www.securityartwork.es/wp-content/uploads/2017/07/Trickbot-report-S2-Grupo.pdf).  
由于 Trickbot 是一种较老的恶意软件，因此针对各种样本已经进行了许多分析，这对于刚开始而言非常有帮助，因为这意味着您可以将自己的工作与他人的观察结果进行核对 [003] [004]。

Methodology 方法论
---------------

As for the structure of this series, I’ll be going through each step of the different phases of execution. Starting with a general overview of the actions performed. For each of the different phases (i.e. programs or scripts used by the malware) we will have a section with Initial triage, followed by static and dynamic analysis where appropriate.  
至于这个系列的结构，我将逐步介绍执行过程中各个阶段的每个步骤。首先是对执行的一般概述。对于每个不同的阶段（即恶意软件使用的程序或脚本），我们将分别进行初始排查，并在适当情况下进行静态和动态分析。

Lastly, I’ll provide a conclusion, present IOCs, and give a list of all references used.  
最后，我将提供结论，呈现 IOCs，并列出所有参考文献。

Starting off we are going to be taking a look at the initial .doc file which looks like the initial phishing document used to lure victims into running the malware. Notice the .doc extension meaning that it uses the old Microsoft format, which means that it does not need the .docm extension, which is needed in newer versions to allow for VBA macro execution.  
我们首

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAACbklEQVRoQ+2aMU4dMRCGZw6RC1CSSyQdLZJtKQ2REgoiRIpQkCYClCYpkgIESQFIpIlkW+IIcIC0gUNwiEFGz+hlmbG9b1nesvGW++zxfP7H4/H6IYzkwZFwQAUZmpJVkSeniFJKA8ASIi7MyfkrRPxjrT1JjZ8MLaXUDiJuzwngn2GJaNd7vyP5IoIYY94Q0fEQIKIPRGS8947zSQTRWh8CwLuBgZx479+2BTkHgBdDAgGAC+fcywoyIFWqInWN9BSONbTmFVp/AeA5o+rjKRJ2XwBYRsRXM4ZXgAg2LAPzOCDTJYQx5pSIVlrC3EI45y611osMTHuQUPUiYpiVooerg7TWRwDAlhSM0TuI+BsD0x4kGCuFSRVzSqkfiLiWmY17EALMbCAlMCmI6IwxZo+INgQYEYKBuW5da00PKikjhNNiiPGm01rrbwDwofGehQjjNcv1SZgddALhlJEgwgJFxDNr7acmjFLqCyJuTd6LEGFttpmkYC91Hrk3s1GZFERMmUT01Xv/sQljjPlMRMsxO6WULwnb2D8FEs4j680wScjO5f3vzrlNJszESWq2LYXJgTzjZm56MCHf3zVBxH1r7ftU1splxxKYHEgoUUpTo+grEf303rPH5hxENJqDKQEJtko2q9zGeeycWy3JhpKhWT8+NM/sufIhBwKI+Mta+7pkfxKMtd8Qtdbcx4dUQZcFCQ2I6DcAnLUpf6YMPxhIDDOuxC4C6djoQUE6+tKpewWZ1wlRkq0qUhXptKTlzv93aI3jWmE0Fz2TeujpX73F9TaKy9CeMk8vZusfBnqZ1g5GqyIdJq+XrqNR5AahKr9CCcxGSwAAAABJRU5ErkJggg==)Phishing document 网络钓鱼文件

We see the sense of urgency used to try to trick a user into getting the macro executed. An interesting note is the use of user action to start code execution, this is likely done to evade detection as almost all EDR/AV till flag files which run code on being opened.  
我们看到了利用紧急感诱使用户执行宏的做法。有趣的是利用用户操作来启动代码执行，这很可能是为了规避检测，因为几乎所有的 EDR/AV 都会标记在打开时运行代码的文件。

Initial triage 初步分类
-------------------

Now that we know that the file is capable of running code and that this will be run through a user action. let's look at what's hiding inside, for this I'll use Olevba from [Oletools [005]](https://github.com/decalage2/oletools) in order to get an idea of the VBA code used in the file. This tool extracts the VBA code from an office document and also applies its own set of triage rules for the detection of suspicious behaviour. Immediately the tool comes back and shows several alerts for suspicious patterns.  
既然我们知道该文件能够运行代码，并且将通过用户操作来运行，让我们来看看其中隐藏了什么，为此我将使用 Oletools 中的 Olevba [005]，以便对文件中使用的 VBA 代码有所了解。该工具可以从办公文件中提取 VBA 代码，并使用自己的一套分析规则来检测可疑行为。立即，该工具返回并显示了几个可疑模式的警报。

![](https://miro.medium.com/v2/resize:fit:1006/1*Ps7FUWnHFkP_A1WXVNo91Q.png)Suspicious VBA patterns in the code  
代码中可疑的 VBA 模式

It does not take long looking through the output before we see how the macro executes the next step. Here we also get the name of the file dropped and the method of execution. Additionally, we see mentions of a function that converts from ASCII to hex, this will be relevant in just a moment.  
浏览输出不久后，我们就能看到宏是如何执行下一步的。在这里，我们还可以得到被放置的文件名称和执行方法。另外，我们还能看到有一个将 ASCII 转换为十六进制的函数提到，这很快就会变得相关起来。

![](https://miro.medium.com/v2/resize:fit:867/1*UqlPF8_7CtE6H-EzJuFteg.png)Execution of dropped malware  
执行已投放的恶意软件![](https://miro.medium.com/v2/resize:fit:1094/1*KAjx9foQApWAPN2MA8IfgA.png) VBA code VBA 代码

Next, to try to get an idea of what the doc might be doing I run strings to see if anything interesting is in the document, immediately a huge blob of what looks like hex data shows up.  
接下来，为了尝试了解文档可能在做什么，我运行了字符串以查看文档中是否有任何有趣的内容，立即出现了一个似乎是十六进制数据的巨大块。

![](https://miro.medium.com/v2/resize:fit:1078/1*Hk6h7x4QuyJn5QhwVGijww.png)Hex string in the file  
文件中的十六进制字符串

Running this through Cyber Chef to get the ASCII representation immediately proves this suspicious as the first bytes is an MZ header [(4D5A — mz) [006]](https://www.netspi.com/blog/technical-blog/web-application-pentesting/magic-bytes-identifying-common-file-formats-at-a-glance/).  
将此输入通过 Cyber Chef 运行，立即获得 ASCII 表示即可证明此次可疑，因为第一个字节是一个 MZ 标头（4D5A — mz） [006]。

![](https://miro.medium.com/v2/resize:fit:1094/1*s_OfYhT7Vv3Pmu2wbIrQPQ.png)Cyberchef decode string Cyberchef 解码字符串

Doing this again shows what is clearly a PE file, which again would match with the behaviour identified earlier.  
再次执行此操作显示明显是 PE 文件，这与之前识别的行为相匹配。

![](https://miro.medium.com/v2/resize:fit:1094/1*rF8glpF11cQBbg3ziUR1tQ.png)Cyberchef decode hex string  
Cyberchef 解码十六进制字符串

Next on the agenda is the extraction of the embedded executable. Let's use strings to extract the file, xxd to decode it, and see if we get a complete binary. And it looks like we were successful.  
下一项议程是提取嵌入式可执行文件。让我们使用 strings 命令提取文件，使用 xxd 进行解码，看看是否得到一个完整的二进制文件。看起来我们成功了。

![](https://miro.medium.com/v2/resize:fit:1094/1*ZvtInc-57KOuP0rl2gm9Mw.png)Extracting binary 提取二进制

It is also worth noting here that the code base of the .doc is very large and includes a lot of what looks to be legitimate VBA code, likely done in an effort to hide functionality.  
这里值得一提的是，.doc 的代码库非常庞大，并包含了大量看起来是合法的 VBA 代码，很可能是为了隐藏功能而做的。

Summary 摘要
----------

This first part of the malware is pretty simple, it runs and extracts a binary file which is double HEX encoded. The extracted file is then run using rundll32. The following IOCs were found:  
恶意软件的第一部分相当简单，它运行并提取一个双十六进制编码的二进制文件。然后使用 rundll32 运行提取的文件。发现了以下的 IOCs：

*   C:\Users\Public\Documents\1.mstsc
*   rundll32 C:\Users\Public\Documents\1.mstsc, dpi360ntW

Since this probably changes for each document a more general IOC can be derived:  
由于这可能会因每个文档而异，可以得出一个更一般的 IOC：

*   rundll32 C:\\Users\\Public\\Documents\\[a-zA-Z0–9]*.mstsc, [a-zA-Z0–9]*  
    rundll32 C:\\Users\\Public\\Documents\\[a-zA-Z0–9]*.mstsc, [a-zA-Z0-9]*

Now that we have the embedded file extracted let's move on to analysing it and see what it Does.  
现在我们已经提取了嵌入式文件，让我们继续分析它，看看它是做什么的。

Initial triage 最初的分类审查
----------------------

Starting off let's inspect the binary to confirm if it is to be run as a DLL, looking at the NtHeaders we see this.  
开始我们来检查二进制文件，以确认它是否应作为 DLL 运行，在查看 NtHeaders 时我们看到了这个。

![](https://miro.medium.com/v2/resize:fit:1094/1*ty7w5h-hGwSL3zTs-e5fbg.png)NtHeaders

This can further be confirmed by looking at the exported functions. This matches the distinct name of the function called by the .dco via rundll32.  
这一点可以通过查看导出函数进一步确认。这与由. dco 通过 rundll32 调用的函数的明确定名相匹配。

![](https://miro.medium.com/v2/resize:fit:1094/1*SdMT18D_9eMhZQ21mImmGw.png)Exported functions 导出的函数

Next, let's give the strings of the binary a look.  
接下来，让我们来看一下二进制的字符串。

Strings 字符串
-----------

As with the .doc, we quickly see some interesting strings.  
与. doc 文件一样，我们很快就可以看到一些有趣的字符串。

![](https://miro.medium.com/v2/resize:fit:1094/1*M8Mrq3CCMh_K87VM4pROMw.png)1.mstsc strings 1.mstsc 字符串

Based purely on the size of the blob this might be another binary.  
根据 blob 大小来看，这可能是另一个二进制文件。

![](https://miro.medium.com/v2/resize:fit:1094/1*TLXCzsXVOClWo3Dkcno4wA.png)String Blob 字符串 Blob

Static Analysis 静态分析
--------------------

Now let's look at the binary itself and see if we can figure out how the strings found previously are used.  
现在让我们看一下二进制文件本身，看看我们是否能够弄清楚先前找到的字符串是如何使用的。

![](https://miro.medium.com/v2/resize:fit:963/1*wd-3QfOdWK4AZseo_LstrQ.png)First function call 第一次函数调用

Looking at the call order of “sub_10001000” we see that the string location of the big encrypted blob is pushed to the stack. And looking at the function itself it looks an awfully lot like a decryption algorithm.  
查看 “sub_10001000” 的调用顺序，我们可以看到大加密块的字符串位置被推送到堆栈上。而且从函数本身来看，它非常像一个解密算法。

![](https://miro.medium.com/v2/resize:fit:391/1*2YaDTmeMur3L5PttgL0CzQ.png)Decryption algorithm 解密算法

After the decryption function a called, we get a call to GetTempTathW followed by the string “2.ps1” before CreateFileW and WriteFile. So I'm guessing the program writes “2.ps1” to the temp directory.  
解密函数 a 被调用后，我们调用了 GetTempPathW，然后在 CreateFileW 和 WriteFile 之前出现了字符串 “2.ps1”。所以我猜测程序会将“2.ps1” 写入临时目录。

![](https://miro.medium.com/v2/resize:fit:563/1*j1_4BR6X7UIbVbRZd5ZmLQ.png)Path name in binary 路径名在二进制中

Next, the program gets the systems directory together with a CMD command to run PowerShell. A small sleep is then called, potentially for AV/EDR evasion, and then a function is called where CreateProcessW is called, so we can assume that the dropped file is then executed by PowerShell coming from CMD.  
接下来，程序获取系统目录以及一个 CMD 命令来运行 PowerShell。然后调用一个小睡眠，可能是为了避开 AV/EDR 检测，然后调用一个函数，在其中调用 CreateProcessW，因此我们可以假设从 CMD 中运行的 PowerShell 会执行所放置的文件。

![](https://miro.medium.com/v2/resize:fit:817/1*9u6Bhln-0_D-hfSMhsXTQw.png)CMD command to execute PowerShell script  
使用 CMD 命令来执行 PowerShell 脚本![](https://miro.medium.com/v2/resize:fit:667/1*XRvGJIciht-uMoAS_3UUBA.png) sub_10001376 contains a call to CreateProcessW  
sub_10001376 包含对 CreateProcessW 的调用![](https://miro.medium.com/v2/resize:fit:1094/1*tOs3zTZD2UPhzVCkWpfitA.png) CMD command string CMD 命令字符串

Then the program exits. So now what? do we want to create a custom decryptor for the PowerShell script? … Nah, let's just load the file in a debugger and cancel the execution after the file is already written for us!  
然后程序退出。那么现在呢？我们想要为 PowerShell 脚本创建自定义解密器吗？... 不，让我们只是在调试器中加载文件，并在文件已经为我们编写后取消执行！

Dynamic debugging to extract the encrypted file  
动态调试以提取加密文件
-------------------------------------------------------------

To load the .dll into a debugger (x96dbg) we can't just point the debugger at the file and click run like we are used to, instead, we have to run it via rundll32. To do this follow the steps outlined in this [guide [007]](https://blog.securitybreak.io/reverse-engineering-tip-analyzing-a-dll-in-x64dbg-b3005d516049) [[008]](https://www.youtube.com/watch?v=BN_xtMKbWxU).  
加载 .dll 文件到调试器（x96dbg）中，我们不能像通常那样简单地将调试器指向文件然后点击运行，而是必须通过 rundll32 来运行它。要做到这一点，请按照本指南中概述的步骤进行操作 [007] [008]。

Next, we run the .dll until the address of the entry point and then place the breakpoint on the entry point of the function.  
接下来，我们运行 .dll 直到入口地址，然后在函数的入口点设置断点。

![](https://miro.medium.com/v2/resize:fit:1094/1*fOXqrgReJRCejun-1VNS3A.png)Dll entry point Dll 入口点

Then we resume execution until we hit the breakpoint for the exported function.  
然后我们恢复执行，直到我们遇到导出函数的断点。

![](https://miro.medium.com/v2/resize:fit:1094/1*7ODASSyhHaM4q23jvu0s7Q.png)Exported function entry point  
导出函数入口点

Since we are just interested in the file created let's just place a breakpoint on CriteFileW/A API call and see if the file is created… and success we get the expected file created at the location we expected.  
由于我们只对所创建的文件感兴趣，让我们在 CriteFileW/A API 调用上设置一个断点，看看文件是否被创建…… 成功了，我们在预期位置得到了所期望的文件。

![](https://miro.medium.com/v2/resize:fit:838/1*jKly_oD3wYgy7mqyVsLISA.png)2.ps1 file creation 2.ps1 文件创建

The file is empty, so we continue execution until the file contents have been decrypted and written to disk.  
文件为空，因此我们会继续执行，直到文件内容被解密并写入磁盘。

Summary 总结
----------

The purpose of this executable is simple, it just extracts an embedded file and decrypts it before writing it to disk. the IOCs for this would be the creation and execution of PowerShell files in the users %temp% directory:  
该可执行文件的目的很简单，它只是提取一个嵌入的文件并在将其写入磁盘之前对其进行解密。 这个操作的特征是在用户的 %temp% 目录中创建并执行 PowerShell 文件：

*   %temp%\\[a-zA-Z0–9]*.ps1

Now let's move to the PowerShell script that was just created. Just quickly giving the file a look through we can see that this is an additional dropper, that uses the PowerShell web client to get a file.  
现在让我们转到刚刚创建的 PowerShell 脚本。快速查看文件，我们可以看到这是一个额外的传送者，它使用 PowerShell Web 客户端来获取文件。

![](https://miro.medium.com/v2/resize:fit:1094/1*40faf-IEJC5c0RO-jVtBYg.png)PowerShell download file PowerShell 下载文件

Next, it looks like it might be checking for different servers where the payload might be hosted:  
接下来，看起来可能是在检查可能托管载荷的不同服务器：

![](https://miro.medium.com/v2/resize:fit:822/1*yTo_qtr-S1kn62db8WjDzA.png)PowerShell URLs PowerShell URLS PowerShell URLS

Extracting all the URLs from the file we get the following list:  
从文件中提取所有的 URL，我们得到以下列表：

*   httx://91.92.109.142/roben.png
*   httx://192.99.255.33/images/roben.png
*   httx://185.183.98.15/roben.png
*   httx://83.138.53.103/images/roben.png
*   httx://172.96.189.216/images/roben.png

Furthermore, we also get the path and file name of the next file to be executed:  
此外，我们还会获取下一个要执行的文件的路径和文件名：

![](https://miro.medium.com/v2/resize:fit:1094/1*VCyEmcJiwxp3nUPAj6E-zw.png)File name and path 文件名和路径

checking if this works, I just place breakpoints on all function calls and see what hits. I was not able to get the file from any of the domains.  
检查这是否有效，我只是在所有函数调用上设置断点，然后看看有什么问题。我无法从任何域获取文件。

Since I was unable to find the original executable referenced in the dropper, let's top the analysis here and save the analysis of the assumed main c2 agent for another post.  
由于我无法找到滴管中引用的原始可执行文件，让我们暂时停止分析，将假定的主 c2 代理的分析留待另一篇帖子再做。

Summary 摘要
----------

The functionality of the script is similar to the ones before it, with the difference that this stage retrieves the file from the internet instead of using an embedded resource. Its IOCs are, file creation and execution:  
脚本的功能类似于之前的脚本，不同之处在于此阶段从互联网检索文件，而不是使用嵌入式资源。它的 IOC 是文件创建和执行：

*   %temp%\\[a-zA-Z0–9]*.blob

and network connections to:  
和网络连接到：

*   httx://91.92.109.142/roben.png
*   httx://192.99.255.33/images/roben.png
*   httx://185.183.98.15/roben.png
*   httx://83.138.53.103/images/roben.png
*   httx://172.96.189.216/images/roben.png

So now that we have seen enough different droppers for the next long while, what did we learn? We learnt that the Trickbot sample studied here uses a bunch of different ways of execution and files in an attempt to stay hidden. All these different droppers and mechanisms of hiding files seem like a clever way to obfuscate intent and make sure that if any part of the chain is caught, the actual malware is not what is getting flagged, rather the disposable droppers will be the ones sacrificed. In the next post, we will be looking at: you guessed it! more droppers! … and the actual meat of the malware the C2 agent and persistence mechanisms.  
现在我们已经看到了足够多的不同的 Dropper，那么我们学到了什么呢？我们学到了这里研究的 Trickbot 样本使用了各种不同的执行方式和文件以尝试保持隐藏。所有这些不同的 Dropper 和隐藏文件的机制似乎是一个聪明的方式来混淆意图，并确保如果链条的任何部分被捕捉到，实际的恶意软件不会被标记，而是可丢弃的 Dropper 将被牺牲。在接下来的帖子中，我们将会看到：你猜对了！更多的 Dropper！…… 以及恶意软件的真正核心 C2 代理和持久性机制。

File names & MD5 Hashes  
文件名和 MD5 哈希值
--------------------------------------

*   1bmd.doc — 23f98d6ff7329618994ac0f3e2b3a394
*   C:\\Users\\Public\\Documents\\1.mstsc, dpi360ntW — 89e0b67600d95c99490e4fc992a50510  
    C:\\Users\\Public\\Documents\\1.mstsc，dpi360ntW — 89e0b67600d95c99490e4fc992a50510
*   %temp%\\2.ps1–767C8910A5A27E1712206E6DEA4FE3D5
*   %temp%\\2.blob — N/A %temp%\\2.blob — 不适用

Network 网络
----------

*   httx://91.92.109.142/roben.png
*   httx://192.99.255.33/images/roben.png
*   httx://185.183.98.15/roben.png
*   httx://83.138.53.103/images/roben.png
*   httx://172.96.189.216/images/roben.png

MITRE 麻省理工学院
------------

*   T1566 — Phishing T1566 — 网络钓鱼
*   T1059 — Command and Scripting Interpreter  
    T1059 — 命令和脚本解释器
*   T1204 — User Execution T1204 — 用户执行
*   T1218.011 — System Binary Proxy Execution: Rundll32  
    T1218.011 — 系统二进制代理执行：Rundll32
*   T1140 — Deobfuscate/Decode Files or Information  
    T1140 — 对文件或信息进行去混淆 / 解码
*   T1564 — Hide Artifacts T1564 — 隐藏文件
*   T1656 — Impersonation T1656 — 冒充
*   T1104 — Multi-Stage Channels  
    T1104 — 多级通道

*   **[001] — CISA advisory —** [https://www.cisa.gov/news-events/cybersecurity-advisories/aa21-076a](https://www.cisa.gov/news-events/cybersecurity-advisories/aa21-076a)  
    [001] — CISA 咨询 — https://www.cisa.gov/news-events/cybersecurity-advisories/aa21-076a
*   **[002] — Malware sample —** [https://bazaar.abuse.ch/sample/8ae73acc01f72c1164324e44045cd74256c3b4be606c0932717a2b593e8c5169/](https://bazaar.abuse.ch/sample/8ae73acc01f72c1164324e44045cd74256c3b4be606c0932717a2b593e8c5169/)  
    [002] — 恶意软件样本 — https://bazaar.abuse.ch/sample/8ae73acc01f72c1164324e44045cd74256c3b4be606c0932717a2b593e8c5169/
*   **[003] — TrickBot malware analysis report —** [https://www.sentinelone.com/blog/trickbot-technical-analysis-banking-trojan-malware/](https://www.sentinelone.com/blog/trickbot-technical-analysis-banking-trojan-malware/)  
    [003] — TrickBot 恶意软件分析报告 — https://www.sentinelone.com/blog/trickbot-technical-analysis-banking-trojan-malware/
*   **[004] — TrickBot malware analysis report —** [https://www.securityartwork.es/wp-content/uploads/2017/07/Trickbot-report-S2-Grupo.pdf](https://www.securityartwork.es/wp-content/uploads/2017/07/Trickbot-report-S2-Grupo.pdf)  
    [004] - TrickBot 恶意软件分析报告 - https://www.securityartwork.es/wp-content/uploads/2017/07/Trickbot-report-S2-Grupo.pdf
*   **[005] —** [https://github.com/decalage2/oletools](https://github.com/decalage2/oletools)
*   **[006] — file signatures —** [https://www.netspi.com/blog/technical-blog/web-application-pentesting/magic-bytes-identifying-common-file-formats-at-a-glance/](https://www.netspi.com/blog/technical-blog/web-application-pentesting/magic-bytes-identifying-common-file-formats-at-a-glance/)  
    [006] — 文件签名 — https://www.netspi.com/blog/technical-blog/web-application-pentesting/magic-bytes-identifying-common-file-formats-at-a-glance/
*   **[007] — [Reverse Engineering Tips] — Analyzing a DLL in x64DBG —** [https://blog.securitybreak.io/reverse-engineering-tip-analyzing-a-dll-in-x64dbg-b3005d516049](https://blog.securitybreak.io/reverse-engineering-tip-analyzing-a-dll-in-x64dbg-b3005d516049)  
    [007] — [逆向工程技巧] — 在 x64DBG 中分析 DLL — https://blog.securitybreak.io/reverse-engineering-tip-analyzing-a-dll-in-x64dbg-b3005d516049
*   **[008] —** [https://www.youtube.com/watch?v=BN_xtMKbWxU](https://www.youtube.com/watch?v=BN_xtMKbWxU)  
    [008] - https://www.youtube.com/watch?v=BN_xtMKbWxU